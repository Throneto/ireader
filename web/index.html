<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ireadervalar ¬∑ Âú®Á∫øEPUBÈòÖËØªÂô®</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" />
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%232563eb'/%3E%3Ctext x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='28' fill='white' font-family='Arial'%3Eüìò%3C/text%3E%3C/svg%3E" />
    <style>
      :root {
        --bg: #ffffff;
        --fg: #111111;
        --accent: #2563eb;
        --muted: #666666;
        --panel: #f6f7f9;
      }
      [data-theme="dark"] {
        --bg: #0b0f18;
        --fg: #e5e7eb;
        --accent: #60a5fa;
        --muted: #cbd5e1;
        --panel: #111827;
      }
      html, body { height: 100%; }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
      }
      .app {
        display: grid;
        grid-template-rows: auto 1fr;
        height: 100%;
      }
      header {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 12px;
        border-bottom: 1px solid #e5e7eb33;
        background: var(--panel);
      }
      header .brand { font-weight: 600; letter-spacing: .2px; }
      header .spacer { flex: 1; }
      header .controls { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
      header input[type="file"] { max-width: 220px; }
      header input[type="url"] { width: 260px; max-width: 40vw; padding: 6px 8px; border-radius: 6px; border: 1px solid #e5e7eb44; background: #ffffff10; color: inherit; }
      header select, header button, header input[type="range"] { padding: 6px 8px; border-radius: 6px; border: 1px solid #e5e7eb44; background: #ffffff10; color: inherit; }
      header button { cursor: pointer; }
      header button.primary { background: var(--accent); color: white; border-color: transparent; }
      header label { color: var(--muted); }
      [data-theme="dark"] header input[type="url"]::placeholder { color: #94a3b8; }
      [data-theme="dark"] header select,
      [data-theme="dark"] header button,
      [data-theme="dark"] header input[type="url"],
      [data-theme="dark"] header input[type="range"] { background: #1f2937; border-color: #475569; color: #f1f5f9; }
      [data-theme="dark"] header label { color: #cbd5e1; }
      [data-theme="dark"] header input[type="file"] { color: #f1f5f9; }
      [data-theme="dark"] header input[type="file"]::file-selector-button { padding: 6px 8px; border-radius: 6px; border: 1px solid #475569; background: #334155; color: #f8fafc; }
      [data-theme="dark"] header input[type="range"]::-webkit-slider-runnable-track { background: #334155; }
      [data-theme="dark"] header input[type="range"]::-webkit-slider-thumb { background: var(--accent); border: 2px solid #1f2937; }

      [data-theme="dark"] header .brand { color: #f8fafc; }
      [data-theme="dark"] header label { color: #e5e7eb; }
      [data-theme="dark"] .sidebar h3 { color: #e6edf7; }
      [data-theme="dark"] .sidebar .toc a { color: #f1f5f9; }
      [data-theme="dark"] .sidebar .toc a:hover { background: #ffffff26; }
      [data-theme="dark"] .sidebar .meta { color: #d1d5db; }

      .layout { display: grid; grid-template-columns: 280px 1fr; min-height: 0; }
      .sidebar { border-right: 1px solid #e5e7eb33; background: var(--panel); min-height: 0; display: flex; flex-direction: column; }
      .sidebar h3 { margin: 12px; font-size: 13px; color: var(--muted); }
      .sidebar .toc { flex: 1; overflow: auto; padding: 8px; }
      .sidebar .toc a { display: block; padding: 6px 8px; border-radius: 6px; color: inherit; text-decoration: none; }
      .sidebar .toc a:hover { background: #ffffff1a; }
      .sidebar .meta { border-top: 1px solid #e5e7eb33; padding: 10px 12px; font-size: 12px; color: var(--muted); }

      #viewer { display: grid; grid-template-rows: 1fr auto; height: calc(100vh - 60px); min-height: 0; justify-items: center; }
      #reader { width: 100%; height: 100%; }
      .reader-fixed #reader { width: var(--reader-fixed-width, 820px); max-width: var(--reader-fixed-width, 820px); }
      .reader-fixed .footer { width: var(--reader-fixed-width, 820px); justify-self: center; }
      .footer { display: flex; gap: 10px; align-items: center; background: #00000012; backdrop-filter: blur(6px); border-radius: 8px; padding: 8px 10px; color: inherit; margin-top: 10px; }
      .footer .progress { flex: 1; height: 6px; border-radius: 999px; background: #ffffff55; overflow: hidden; }
      .footer .progress > div { height: 100%; background: var(--accent); width: 0%; }
      .footer .loc { font-size: 12px; white-space: nowrap; }
      .footer button { padding: 6px 8px; border-radius: 6px; border: 0; cursor: pointer; }
      .footer button.nav { background: #00000050; color: white; }
    </style>
  </head>
  <body>
    <div class="app" id="app" data-theme="light">
      <header>
        <div class="brand">ireadervalar</div>
        <div class="controls">
          <input id="file-input" type="file" accept=".epub" />
          <input id="url-input" type="url" placeholder="ËæìÂÖ•EPUBÂú∞ÂùÄ" />
          <button id="open-url" class="primary">ÊâìÂºÄ</button>
          <input id="admin-password" type="password" placeholder="ÁÆ°ÁêÜÂëòÂØÜÁ†Å" />
          <button id="login-btn">ÁôªÂΩï</button>
          <span id="login-status" style="color: var(--muted);"></span>
          <button id="logout-btn" style="display:none">ÈÄÄÂá∫ÁôªÂΩï</button>
          <button id="prev">‰∏ä‰∏ÄÈ°µ</button>
          <button id="next">‰∏ã‰∏ÄÈ°µ</button>
          <label for="font-size">Â≠ó‰Ωì</label>
          <input id="font-size" type="range" min="80" max="180" value="100" />
          <label for="theme">‰∏ªÈ¢ò</label>
          <select id="theme">
            <option value="light">ÊµÖËâ≤</option>
            <option value="dark">Ê∑±Ëâ≤</option>
            <option value="sepia">ÁæäÁöÆÁ∫∏</option>
          </select>
          <label for="spread">ÊéíÁâà</label>
          <select id="spread">
            <option value="none">ÂçïÈ°µ</option>
            <option value="auto" selected>Ëá™Âä®</option>
          </select>
          <label for="width-mode">Á™óÂè£</label>
          <select id="width-mode">
            <option value="auto" selected>Ëá™ÈÄÇÂ∫î</option>
            <option value="fixed">Âõ∫ÂÆö</option>
          </select>
          <input id="width" type="range" min="600" max="1200" value="820" />
        </div>
        <div class="spacer"></div>
      </header>

      <div class="layout">
        <aside class="sidebar">
          <h3>ÊúçÂä°Âô®‰π¶Â∫ì</h3>
          <div class="toc" id="server-library"></div>
          <h3>‰π¶Â∫ì</h3>
          <div class="toc" id="library"></div>
          <h3>ÁõÆÂΩï</h3>
          <div class="toc" id="toc"></div>
          <div class="meta" id="meta">Êú™Âä†ËΩΩ‰π¶Á±ç</div>
        </aside>
        <main id="viewer">
          <div id="reader"></div>
          <div class="footer" id="footer" hidden>
            <button class="nav" id="prev2">‰∏ä‰∏ÄÈ°µ</button>
            <button class="nav" id="next2">‰∏ã‰∏ÄÈ°µ</button>
            <div class="progress"><div id="progress-bar"></div></div>
            <div class="loc" id="loc-info">0%</div>
          </div>
        </main>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs@0.3/dist/epub.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
    <script>
      const appEl = document.getElementById('app');
      const fileInput = document.getElementById('file-input');
      const urlInput = document.getElementById('url-input');
      const openUrlBtn = document.getElementById('open-url');
      const adminPwInput = document.getElementById('admin-password');
      const loginBtn = document.getElementById('login-btn');
      const logoutBtn = document.getElementById('logout-btn');
      const loginStatus = document.getElementById('login-status');
      const prevBtn = document.getElementById('prev');
      const nextBtn = document.getElementById('next');
      const prevBtn2 = document.getElementById('prev2');
      const nextBtn2 = document.getElementById('next2');
      const fontSize = document.getElementById('font-size');
      const themeSel = document.getElementById('theme');
      const spreadSel = document.getElementById('spread');
      const tocEl = document.getElementById('toc');
      const metaEl = document.getElementById('meta');
      const footerEl = document.getElementById('footer');
      const progressBar = document.getElementById('progress-bar');
      const locInfo = document.getElementById('loc-info');
      const widthModeSel = document.getElementById('width-mode');
      const widthRange = document.getElementById('width');
      const libraryEl = document.getElementById('library');
      const serverLibraryEl = document.getElementById('server-library');

      let book = null;
      let rendition = null;
      let blobUrl = null;
      let locationsReady = false;
      let serverLoggedIn = false;
      let csrfToken = null;
      let currentBookId = null;
      let db = null;
      let dbReady = false;

      function reset() {
        if (rendition) { try { rendition.destroy(); } catch (e) {} rendition = null; }
        if (book) { try { book.destroy(); } catch (e) {} book = null; }
        if (blobUrl) { URL.revokeObjectURL(blobUrl); blobUrl = null; }
        tocEl.innerHTML = '';
        metaEl.textContent = 'Êú™Âä†ËΩΩ‰π¶Á±ç';
        footerEl.hidden = true;
        progressBar.style.width = '0%';
        locInfo.textContent = '0%';
        locationsReady = false;
      }

      function initThemes() {
        if (!rendition) return;
        rendition.themes.register('light', { 'body': { 'background': '#ffffff', 'color': '#111111' } });
        rendition.themes.register('dark', { 'body': { 'background': '#0b0f18', 'color': '#e5e7eb' } });
        rendition.themes.register('sepia', { 'body': { 'background': '#f4ecd8', 'color': '#5b4636' } });
        rendition.themes.select(themeSel.value);
        rendition.themes.fontSize(fontSize.value + '%');
      }

      function updateSpread() {
        if (!rendition) return;
        const spread = spreadSel.value;
        rendition.spread(spread);
      }

      function applyReaderWidth() {
        const mode = widthModeSel.value;
        const wpx = parseInt(widthRange.value, 10);
        if (mode === 'fixed') {
          appEl.classList.add('reader-fixed');
          appEl.style.setProperty('--reader-fixed-width', wpx + 'px');
        } else {
          appEl.classList.remove('reader-fixed');
        }
        if (rendition) {
          const readerEl = document.getElementById('reader');
          const w = readerEl.clientWidth;
          const h = readerEl.clientHeight;
          try { rendition.resize(w, h); } catch (e) {}
        }
        widthRange.style.display = mode === 'fixed' ? '' : 'none';
      }

      function updateProgress(loc) {
        if (!book || !locationsReady) return;
        const cfi = loc && loc.start ? loc.start.cfi : rendition && rendition.location && rendition.location.start ? rendition.location.start.cfi : null;
        if (!cfi) return;
        try {
          const pct = Math.round(book.locations.percentageFromCfi(cfi) * 100);
          progressBar.style.width = pct + '%';
          locInfo.textContent = pct + '%';
          if (currentBookId && dbReady) {
            const dt = Date.now();
            db.put('reading', { bookId: currentBookId, lastCfi: cfi, lastPct: pct, updatedAt: dt });
            db.get('books', currentBookId).then(rec => { if (rec) { rec.updatedAt = dt; db.put('books', rec); } });
          }
        } catch (e) { }
      }

      async function loadBook(source, startCfi) {
        reset();
        try {
          if (source instanceof File) {
            book = ePub();
            const buffer = await source.arrayBuffer();
            await book.open(buffer);
          } else if (source instanceof Blob) {
            book = ePub();
            const buffer = await source.arrayBuffer();
            await book.open(buffer);
          } else if (source && source.byteLength !== undefined) {
            book = ePub();
            await book.open(source);
          } else {
            book = ePub(source);
          }
        } catch (e) {
          alert('Âä†ËΩΩ‰π¶Á±çÂ§±Ë¥•Ôºö' + e.message);
          return;
        }
        rendition = book.renderTo('reader', { width: '100%', height: '100%', spread: spreadSel.value, allowScriptedContent: true });
        await rendition.display(startCfi || undefined);
        initThemes();
        applyReaderWidth();
        footerEl.hidden = false;

        try {
          const nav = await book.loaded.navigation;
          tocEl.innerHTML = '';
          nav.toc.forEach(item => {
            const a = document.createElement('a');
            a.textContent = item.label;
            a.href = '#';
            a.onclick = async (ev) => {
              ev.preventDefault();
              try { await rendition.display(item.href); }
              catch (e) { const base = (item.href || '').split('#')[0]; try { await rendition.display(base); } catch (_) {} }
            };
            tocEl.appendChild(a);
          });
        } catch (e) {
          tocEl.textContent = 'Êú™ÊâæÂà∞ÁõÆÂΩï';
        }

        try {
          const meta = await book.loaded.metadata;
          metaEl.textContent = `${meta.title || 'Êú™Áü•Ê†áÈ¢ò'} ¬∑ ${meta.creator || 'Êú™Áü•‰ΩúËÄÖ'}`;
        } catch (e) { metaEl.textContent = 'Êú™Áü•‰π¶Á±ç'; }

        try {
          await book.ready;
          await book.locations.generate(1600);
          locationsReady = true;
          updateProgress(rendition.location);
        } catch (e) { }

        rendition.on('relocated', updateProgress);
      }

      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        await importFileAndOpen(file);
        await uploadToServer(file);
      });

      openUrlBtn.addEventListener('click', async () => {
        const url = urlInput.value.trim();
        if (!url) return;
        await importUrlAndOpen(url);
        if (serverLoggedIn) {
          const res = await fetch(url);
          const blob = await res.blob();
          const file = new File([blob], (url.split('/').pop() || 'book.epub'), { type: 'application/epub+zip' });
          await uploadToServer(file);
        }
      });

      prevBtn.addEventListener('click', () => rendition && rendition.prev());
      nextBtn.addEventListener('click', () => rendition && rendition.next());
      prevBtn2.addEventListener('click', () => rendition && rendition.prev());
      nextBtn2.addEventListener('click', () => rendition && rendition.next());
      themeSel.addEventListener('change', (e) => { appEl.setAttribute('data-theme', e.target.value === 'dark' ? 'dark' : 'light'); rendition && rendition.themes.select(e.target.value); saveSetting('theme', e.target.value); });
      fontSize.addEventListener('input', (e) => { rendition && rendition.themes.fontSize(e.target.value + '%'); saveSetting('fontSize', e.target.value); });
      spreadSel.addEventListener('change', (e) => { updateSpread(); saveSetting('spread', e.target.value); });
      widthModeSel.addEventListener('change', (e) => { applyReaderWidth(); saveSetting('widthMode', e.target.value); });
      widthRange.addEventListener('input', (e) => { applyReaderWidth(); saveSetting('width', e.target.value); });

      window.addEventListener('keydown', (e) => {
        if (!rendition) return;
        if (e.key === 'ArrowRight') { rendition.next(); }
        if (e.key === 'ArrowLeft') { rendition.prev(); }
      });
      async function login() {
        const pw = adminPwInput.value.trim();
        if (!pw) return;
        try {
          loginBtn.disabled = true; loginStatus.textContent = 'ÁôªÂΩï‰∏≠...';
          const ac = new AbortController();
          const timer = setTimeout(() => ac.abort(), 12000);
          const res = await fetch('/api/login', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ password: pw }), signal: ac.signal, credentials: 'same-origin' });
          clearTimeout(timer);
          if (res.ok) { const j = await res.json(); csrfToken = j.csrf; serverLoggedIn = true; adminPwInput.style.display = 'none'; loginBtn.style.display = 'none'; logoutBtn.style.display = ''; loginStatus.textContent = 'Â∑≤ÁôªÂΩï'; await refreshServerLibrary(); } else { loginStatus.textContent = 'ÁôªÂΩïÂ§±Ë¥•'; }
        } catch(e) { loginStatus.textContent = 'ÊúçÂä°Âô®Êó†ÂìçÂ∫î'; }
        finally { loginBtn.disabled = false; }
      }
      loginBtn.addEventListener('click', login);

      async function logout() {
        await fetch('/api/logout', { method: 'POST', credentials: 'same-origin' });
        serverLoggedIn = false;
        csrfToken = null;
        adminPwInput.style.display = '';
        loginBtn.style.display = '';
        logoutBtn.style.display = 'none';
        serverLibraryEl.innerHTML = '';
      }
      logoutBtn.addEventListener('click', logout);

      async function refreshServerLibrary() {
        try {
          const res = await fetch('/api/books', { credentials: 'same-origin', cache: 'no-store' });
          if (!res.ok) {
            serverLoggedIn = false;
            adminPwInput.style.display = '';
            loginBtn.style.display = '';
            loginStatus.textContent = 'Êú™ÊéàÊùÉÊàñ‰ºöËØùÂ§±Êïà';
            serverLibraryEl.innerHTML = '';
            return;
          }
          serverLoggedIn = true; adminPwInput.style.display = 'none'; loginBtn.style.display = 'none';
          const data = await res.json();
          serverLibraryEl.innerHTML = '';
          data.items.forEach(item => {
            const row = document.createElement('div');
            const a = document.createElement('a');
            const name = item.pathname.split('/').pop();
            const label = (item.title || name) + (item.author ? (' ¬∑ ' + item.author) : '');
            a.textContent = label;
            a.href = '#';
            a.onclick = async (ev) => { ev.preventDefault(); await openServerBook(item); };
            const delBtn = document.createElement('button');
            delBtn.textContent = 'Âà†Èô§';
            delBtn.onclick = async () => { await deleteServerBook(item.pathname, delBtn); };
            row.appendChild(a);
            row.appendChild(document.createTextNode(' '));
            row.appendChild(delBtn);
            serverLibraryEl.appendChild(row);
            if ((!item.title || !item.author) && item.metaUrl) {
              (async () => {
                try {
                  const r = await fetch(item.metaUrl);
                  if (r.ok) {
                    const j = await r.json();
                    const lbl = (j.title || name) + (j.author ? (' ¬∑ ' + j.author) : '');
                    a.textContent = lbl;
                  }
                } catch(e) {}
              })();
            }
          });
        } catch (e) { serverLoggedIn = false; }
      }

      async function deleteServerBook(id, btn) {
        if (!serverLoggedIn || !csrfToken) { alert('ËØ∑ÂÖàÁôªÂΩï'); return; }
        try {
          if (btn) { btn.disabled = true; btn.textContent = 'Âà†Èô§‰∏≠...'; }
          const headers = { 'X-CSRF-Token': csrfToken };
          const res = await fetch('/api/delete?id=' + encodeURIComponent(id), { method: 'DELETE', headers, credentials: 'same-origin' });
          if (!res.ok) {
            if (res.status === 401) {
              serverLoggedIn = false; adminPwInput.style.display = ''; loginBtn.style.display = '';
              alert('Êú™ÊéàÊùÉÔºåËØ∑ÈáçÊñ∞ÁôªÂΩï');
            } else if (res.status === 403) {
              alert('Âà†Èô§Â§±Ë¥•Ôºö‰ª§ÁâåÊó†Êïà');
            } else {
              alert('Âà†Èô§Â§±Ë¥•Ôºö' + res.status);
            }
          }
        } catch(e) {
          alert('Âà†Èô§Â§±Ë¥•Ôºö' + (e && e.message ? e.message : 'ÁΩëÁªúÈîôËØØ'));
        } finally {
          try {
            await refreshServerLibrary();
          } finally {
            if (btn) { btn.disabled = false; btn.textContent = 'Âà†Èô§'; }
          }
        }
      }

      async function openServerBook(item) {
        try {
          const res = await fetch(item.url);
          if (!res.ok) throw new Error('‰∏ãËΩΩÂ§±Ë¥•Ôºö' + res.status)
          const blob = await res.blob();
          const buffer = await blob.arrayBuffer();
          await ensureDB();
          const id = await saveBookBuffer(buffer, { title: item.pathname.split('/').pop(), size: blob.size });
          const r = await db.get('reading', id);
          currentBookId = id;
          await refreshLibrary();
          await loadBook(buffer, r && r.lastCfi ? r.lastCfi : null);
          try {
            const meta = await extractMeta(buffer, { title: item.pathname.split('/').pop() });
            await updateServerMeta(item.pathname, meta.title, meta.author);
          } catch (e) {}
        } catch(e) {
          alert('ÊâìÂºÄÊúçÂä°Âô®‰π¶Á±çÂ§±Ë¥•Ôºö' + (e && e.message ? e.message : 'Êú™Áü•ÈîôËØØ'));
        }
      }

      async function uploadToServer(file) {
        if (!serverLoggedIn) return;
        const res = await fetch('/api/upload', { method: 'POST', headers: { 'Content-Type': 'application/epub+zip', 'X-Filename': file.name || 'book.epub' }, body: await file.arrayBuffer(), credentials: 'same-origin' });
        if (res.ok) {
          const j = await res.json();
          try {
            const buffer = await file.arrayBuffer();
            const meta = await extractMeta(buffer, { title: file.name });
            await updateServerMeta(j.pathname, meta.title, meta.author);
          } catch (e) {}
          await refreshServerLibrary();
        }
      }

      async function updateServerMeta(pathname, title, author) {
        if (!serverLoggedIn || !csrfToken) return;
        await fetch('/api/metadata', { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': csrfToken }, body: JSON.stringify({ pathname, title, author }), credentials: 'same-origin' });
      }

      function initCsrfFromCookie() {
        try {
          const c = document.cookie || '';
          const m = c.split(';').map(s=>s.trim()).find(x=>x.startsWith('csrf='));
          csrfToken = m ? m.slice('csrf='.length) : csrfToken;
        } catch(e) {}
      }

      async function extractMeta(buffer, defaults) {
        let title = defaults && defaults.title ? defaults.title : '';
        let author = defaults && defaults.author ? defaults.author : '';
        try {
          const zip = await JSZip.loadAsync(buffer);
          let container = zip.file('META-INF/container.xml') || zip.file('meta-inf/container.xml');
          if (!container) {
            const cand = Object.keys(zip.files).find(p => p.toLowerCase().endsWith('container.xml'));
            if (cand) container = zip.file(cand);
          }
          let opfPath = null;
          if (container) {
            const cxml = await container.async('text');
            const m = cxml.match(/full-path\s*=\s*"([^"]+)"/i);
            if (m) opfPath = m[1];
          }
          if (!opfPath) {
            const candOpf = Object.keys(zip.files).find(p => p.toLowerCase().endsWith('.opf'));
            if (candOpf) opfPath = candOpf;
          }
          if (opfPath) {
            const opf = zip.file(opfPath);
            if (opf) {
              const xml = await opf.async('text');
              const tm = xml.match(/<dc:title[^>]*>([\s\S]*?)<\/dc:title>/i);
              const am = xml.match(/<dc:creator[^>]*>([\s\S]*?)<\/dc:creator>/i);
              if (tm && tm[1]) { title = tm[1].trim(); }
              if (am && am[1]) { author = am[1].trim(); }
            }
          }
        } catch(e) {}
        return { title, author };
      }
      document.addEventListener('DOMContentLoaded', async () => {
        initCsrfFromCookie();
        await ensureDB();
        await refreshLibrary();
        await loadSettings();
        registerSW();
        await refreshServerLibrary();
      });

      function registerSW() {
        if ('serviceWorker' in navigator) { try { navigator.serviceWorker.register('/sw.js'); } catch(e) {} }
      }

      async function initDB() {
        const { openDB } = idb;
        db = await openDB('ireader', 1, {
          upgrade(db) {
            if (!db.objectStoreNames.contains('books')) {
              const s = db.createObjectStore('books', { keyPath: 'id', autoIncrement: true });
              s.createIndex('updatedAt', 'updatedAt');
            }
            if (!db.objectStoreNames.contains('reading')) {
              db.createObjectStore('reading', { keyPath: 'bookId' });
            }
            if (!db.objectStoreNames.contains('settings')) {
              db.createObjectStore('settings', { keyPath: 'id' });
            }
          }
        });
        dbReady = true;
      }

      async function ensureDB() { if (!dbReady) { await initDB(); } }

      async function refreshLibrary() {
        await ensureDB();
        const books = await db.getAll('books');
        libraryEl.innerHTML = '';
        books.sort((a,b)=> (b.updatedAt||0) - (a.updatedAt||0));
        books.forEach(b=>{
          const a = document.createElement('a');
          a.textContent = (b.title || 'Êú™ÂëΩÂêç') + (b.author ? ' ¬∑ ' + b.author : '');
          a.href = '#';
          a.onclick = async (ev) => { ev.preventDefault(); await openBookFromDB(b.id); };
          libraryEl.appendChild(a);
        });
      }

      async function saveBookBuffer(buffer, defaults) {
        let title = defaults && defaults.title ? defaults.title : '';
        let author = defaults && defaults.author ? defaults.author : '';
        try {
          const zip = await JSZip.loadAsync(buffer);
          let container = zip.file('META-INF/container.xml') || zip.file('meta-inf/container.xml');
          if (!container) {
            const cand = Object.keys(zip.files).find(p => p.toLowerCase().endsWith('container.xml'));
            if (cand) container = zip.file(cand);
          }
          let opfPath = null;
          if (container) {
            const cxml = await container.async('text');
            const m = cxml.match(/full-path\s*=\s*"([^"]+)"/i);
            if (m) opfPath = m[1];
          }
          if (!opfPath) {
            const candOpf = Object.keys(zip.files).find(p => p.toLowerCase().endsWith('.opf'));
            if (candOpf) opfPath = candOpf;
          }
          if (opfPath) {
            const opf = zip.file(opfPath);
            if (opf) {
              const xml = await opf.async('text');
              const tm = xml.match(/<dc:title[^>]*>([\s\S]*?)<\/dc:title>/i);
              const am = xml.match(/<dc:creator[^>]*>([\s\S]*?)<\/dc:creator>/i);
              if (tm && tm[1]) { title = tm[1].trim(); }
              if (am && am[1]) { author = am[1].trim(); }
            }
          }
        } catch(e) {}
        const rec = { title, author, size: (defaults && defaults.size) ? defaults.size : (buffer.byteLength || 0), createdAt: Date.now(), updatedAt: Date.now(), blob: buffer };
        const id = await db.add('books', rec);
        return id;
      }

      async function openBookFromDB(id) {
        await ensureDB();
        const rec = await db.get('books', id);
        if (!rec) return;
        const r = await db.get('reading', id);
        currentBookId = id;
        await loadBook(rec.blob, r && r.lastCfi ? r.lastCfi : null);
      }

      async function importFileAndOpen(file) {
        await ensureDB();
        const buffer = await file.arrayBuffer();
        const id = await saveBookBuffer(buffer, { title: file.name, size: file.size });
        const r = await db.get('reading', id);
        currentBookId = id;
        await refreshLibrary();
        await loadBook(buffer, r && r.lastCfi ? r.lastCfi : null);
      }

      async function importUrlAndOpen(url) {
        await ensureDB();
        const res = await fetch(url);
        const blob = await res.blob();
        const buffer = await blob.arrayBuffer();
        const id = await saveBookBuffer(buffer, { title: url.split('/').pop() || url, size: blob.size });
        const r = await db.get('reading', id);
        currentBookId = id;
        await refreshLibrary();
        await loadBook(buffer, r && r.lastCfi ? r.lastCfi : null);
      }

      function saveSetting(id, value) { if (!dbReady) return; try { db.put('settings', { id, value }); } catch(e) {} }

      async function loadSettings() {
        await ensureDB();
        const t = await db.get('settings', 'theme');
        if (t && t.value) { themeSel.value = t.value; appEl.setAttribute('data-theme', t.value === 'dark' ? 'dark' : 'light'); }
        const fs = await db.get('settings', 'fontSize');
        if (fs && fs.value) { fontSize.value = String(fs.value); }
        const sp = await db.get('settings', 'spread');
        if (sp && sp.value) { spreadSel.value = sp.value; }
        const wm = await db.get('settings', 'widthMode');
        if (wm && wm.value) { widthModeSel.value = wm.value; }
        const w = await db.get('settings', 'width');
        if (w && w.value) { widthRange.value = String(w.value); }
        applyReaderWidth();
      }
    </script>
  </body>
</html>